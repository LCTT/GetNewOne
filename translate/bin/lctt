#!/bin/bash

# exit on exceptions.
# 退出异常，脚本开发过程中很有帮助
set -e

# save LCTT TranslateProject directory and cd to lctt-cli project root.
# 保存 LCTT TranslateProject 目录然后返回到 lctt-cli 项目根目录
export LCTT_DIR="$(pwd)"
## 设置环境变量为当前目录位置
cd "$(dirname "$(readlink -f "$0")")"/..
## 取得脚本文件所在目录，然后将当前目录切换过去
## 一直跟随符号链接，直至“$0	当前脚本的文件名”为非符号链接文件

# FIXME: refactor with yml.
# 注释：用生成代码的正式语言重构。
usage() {
## 用法(){
  echo "LCTT Helper"
  echo "Usage: $0 COMMAND [OPTION...]"
  echo
  echo "Commands:"
  echo "  list      List LCTT articles"
  echo "  claim     Claim an article"
# echo "  申明      申明一篇文章    "
  echo "  submit    Submit an claimed article"
# echo "  提交      提交文章的声明           "
  echo "  help      Print usage for commands"
# echo "  帮助      打印这个脚本的用法      "
}

# first argument COMMAND is mandatory, or print usage and exit otherwise.
# 第一个参数 "COMMAND" 是必需的，不然的话打印 "注释" 并退出。
[ $# -lt 1 ] && {
## 传递给脚本或函数的参数总数。-lt 小于（less than）
  usage
  exit 1
}

# parse arguments.
# 参数剖析
COMMAND="$1"
## COMMAND="第一个参数"
COMMAND_SCRIPT="./lib/commands/${COMMAND}"
## $0下的lib->commands->"list"

# run command if exists, or print error and usage then exit otherwise.
# 除非运行的命令存在，否则打印错误和用法（即帮助信息）退出。
[ -x "$COMMAND_SCRIPT" ] && "$COMMAND_SCRIPT" ${@:2} || {
## "COMMAND_SCRIPT"存在并且可以执行 && "COMMAND_SCRIPT"的引用值从第二个位置变量开始 || {
  ./lib/error "Unknown command $COMMAND"
## 引用./lib/error -> $@="Unknown command $COMMAND"
  usage
  exit 1
}
